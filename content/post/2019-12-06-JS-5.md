---
title: "JavaScript 入门 V：函数"
date: 2019-12-03T09:00:59+08:00
draft: false
tags: ["JavaScript", "前端", "入门"]
categories: ["从小白开始的前端学习之旅"]
author: "Harvey Zhang"
mathjax: true
toc: true
---

本文将介绍对象的另外的一种比较重要的形式：函数。除了比较函数一些比较基本的概念以外，也记录了关于 this、作用域、调用时机等对于新手来说比较复杂的东西。

<!--more-->

> 本文大部分内容是 [饥人谷](http://jirengu.com) 方老师课上的讲的内容的总结，并参考了 Wikipedia 和互联网上的其他公开资料。

## 函数的定义

函数的定义大致有以下几种：

具名函数

```js
function 函数名(形参) { 函数体 }
```

匿名函数

```js
let a = function(形参) { 函数体 } // 右边的部分也叫函数表达式
```

也可以用构造函数来进行定义

```js
let a = new Function()
```

ES 6 新语法中引入了箭头函数

```js
输入参数 => 输出参数
( 输入参数1, 输入参数2 )  => 输出参数
( 输入参数1, 输入参数2 )  => {
    语句1
    语句2
    return 语句
}
x => ({ name: '...' }) // 如果要返回对象，就要加圆括号
```

## 作用域

Key Points:

- **全局变量与局部变量**：在 **顶级作用域** 声明的变量是全局变量（比如 window 上的变量是全局变量）；其他的都是局部变量
- **就近原则**：如果有多个作用域有同名变量 `a`，那么查找 `a` 的声明时，就向上取最近的作用域
- **闭包**：函数用到了外部的变量，则 **函数 + 这个变量 = 闭包**
- **作用域的确定与函数的执行无关（JavaScript 的作用域为静态作用域），但变量的值在函数执行的时候才能确定**

下一段将会讲解一个关于作用域的比较麻烦的情况

## 函数的执行时机

> 函数中变量的值是在执行的时候确定的，而不是在定义的时候。

我们再来看一下这一段代码：

```js
let i = 0 // 创建一个全局变量 i
for (i = 0; i < 6; i++) {
    setTimeout(() => {
        console.log(i)
    }, 0)
}
```

上面代码运行的结果是将会打印出 6 个 `6`，这是因为 setTimeout 有 **超时延迟** ，如果当前页面（或者操作系统/浏览器本身）**被其他任务占用**，则会产生延时，**等到其他任务执行完之后，setTimeout 里面的函数才会被执行**。

也就是说，等到该执行 `console.log(i)` 这句话的时候，`i` 的值已经被因为循环而修改成了 `6`。

为了让上面的代码能够打印出 `0 1 2 3 4 5`，我们可以这样改写代码：

```js
for (let i = 0; i < 6; i++) {
    setTimeout(() => {
        console.log(i)
    }, 0)
}
```

这样 `i` 的作用域就只在 `for 循环` 内部，同时每次循环的时候，都会创建一个 **新的局部变量 `i`**。当然要注意的是，这并不是改变了函数的执行顺序，`console.log(i)` 这句话仍然是在 `for 循环` 执行完毕之后再执行的，我们可以做一个实验：

```js
for (let i = 0; i < 6; i++) {
    setTimeout(() => {
        console.log(i)
    }, 0)
    console.log('End')
}
```

这样写代码最后将会先打印 6 个 `'End'`，再打印 `0 1 2 3 4 5`。

> 那么还没有别的解决方法呢？

其实是有的，在 `let` 出现之前，我们仍然有其他的方法来达到想要的效果，下面就简单介绍一下其中的几种方法，他们的核心思路其实都是 **把每一次的 `i` 都保存起来**：

**第一种方法** 实际上跟刚才的新语法原理上差不多，只不过更容易理解一些，先上代码：

```js
let i   // 创建全局变量 i
for (i = 0; i < 6; i++) {
    let j = i   // 创建局部变量 j
    setTimeout(() => {
        console.log(j)
    }, 0)
    console.log('End')
}
```

原理非常简单，我们在 `for 循环` 内部创建了一个新的 **具有块级作用域的局部变量 `j`**，每次循环的时候，都会创建一个新的 `j`，于是我们用 `j` 来保存了每次的 `i`，当然他也会先打印 6 个 `'End'`，再打印 `0 1 2 3 4 5`。


**第二种方法**，在 `let` 诞生之前，我们可以借助函数的传值来保存每一次的 `i`：

```js
var i   // 这里是 let 还是 var 都不要紧，都是创建了一个全局变量，就像最开始的情况一样
function doSetTimeout(i) {
    setTimeout(() => {
        console.log(i)
    }, 0)
}
for (i = 0; i < 6; i++) {
    doSetTimeout(i)
    console.log('End')
}
```

看看代码执行的流程：

1. 首先我们定义了一个中间函数 `doSetTimeout`
2. 然后在 `for 循环` 中调用了这个函数
3. 每次循环调用的时候，就传入一个参数 `i` 给 `doSetTimeout`，
4. `doSetTimeout` 用形参 `i` 接收了这个传给他的参数，在这一步，实际上已经产生了 **2 个 `i`**：
   - 一个是 **全局变量 `i`**（也就是 `for 循环` 中的 `i`）
   - 一个是 `doSetTimeout` 这个函数里面的 **局部变量 `i`**
6. 每一次循环就会调用 `doSetTimeout` 一次，同时 `doSetTimeout` 会给自己创建一个 **不一样的、新的局部变量 `i`**
7. 等循环结束后，`doSetTimeout` 再打印出所有的 **局部变量 `i`**

> 注意这里仍然没有改变执行的顺序！最终的结果仍然是先打印出 6 个 `'End'`，再打印 `0 1 2 3 4 5`。

当我们理解了上面的写法的时候，我们可以最后看一下在 `let` 还没有出来的时代，是怎么借助函数创建 **块级局部变量** 的，也就是我们的 **第三种写法**：

```js
var i   // 创建全局变量 i
for (i = 0; i < 6; i++) {
    (function() {
        var j = i   // 创建局部变量 j
        setTimeout(() => {
            console.log(j)
        }, 0)
    })()
    console.log('End')
}
```

这里，我们使用了 **立即执行函数**：`(function(...){...})()`，这种写法表示我声明一个函数，并且马上执行他。当执行结束之后，因为这个函数没有名字，也没有将地址赋值给某个变量，因此我们没办法再从别的地方再调用他，相当于是“一次性函数”。

`var` 的作用域是函数级作用域，因此每个函数里面的 `j` 都是不一样的，我们再一次聪明地用 **局部变量** 保存了每一次 **全局变量** 的变化！

> 总结：这几种写法都是为了利用 **局部作用域** ——他们有的利用了 ES 6 为我们提供的 **`let`**，有的使用了 **函数** ——来保存每一次 `for 循环` 中 **全局变量** 不同的值，**但是，他们均不会改变执行的顺序！**

## 参数

Key Points：

- **参数传递**：简单类型复制值，对象复制地址
- **形参**：实际上就函数中一个**新变量的声明**：`var x = arguments[0]`
- **`arguments`**：调用函数就会传入 `arguments`，他实际上是一个包含传入参数的 **伪数组**

形参传递可多可少，看下面一段代码：

```js
function add(x) {
    return x + arguments[1]
}
// 此时若执行 add(1, 2)，将会返回 3

function add(x, y, z) {
    return x + y
}
// 此时若执行 add(1, 2)，将会返回 3
```

## this

Key Points:

- 如果不给定任何条件，`this` 为 `window`
- 如果想要指定 `this`，需要使用 `fn.call(..., 1, 2, 3)`，如果传入的 `this` 不是对象，则将会默认会被封装成对象

### this 解决了什么问题？

> this 的存在是为了解决函数想要获取一个对象的引用的问题

直接看 this 是怎么解决这个问题的吧：

```js
    let person = {
        name: 'harvey',
        sayHi() {
            console.log('hello' + this.name)
        }
    }
    person.sayHi()  // 在这句话中，系统会自动地把 person 作为 this 传给 sayHi，这样就解决了 sayHi 想要用到某个对象的问题了
```

因为平时都是 JavaScript 自动帮我们传递了 `this`，所以我们可能对其中发生了什么并不了解。

在这里，我们把常用的函数调用的方法称为 `this` 的 **隐式传递**，与之相对应的则是使用 `call` 或者 `apply` 的 **显式传递**：

```js
person.sayHi()              // 隐式传递
person.sayHi.call(person)   // 显式传递
```

当然我们还可以再后面加参数：`person.sayHi.call(person, 1, 2, 3)`，使用 `apply` 和 `call` 的不同就在于 `apply` 后面的参数要用中括号括起来，因为他传递的是数组。

### 绑定 this

使用 `bind` 可以绑定 `this`：

```js
function f1(p1, p2) {
    console.log(this, p1, p2)
}
let f3 = f1.bind( {name:'hai'}, 'hi' )  // 相当于让 f3 的 this 和 arguments 永远等于 bind 的内容
f3()    // 等价于 f1.call( {name:'hai'}, 'hi' )，
```

### 箭头函数

箭头函数没有 `arguments` 和 `this`，箭头函数里面的 `this` 就是外面的 `this`，就算加 `call` 也没有

```js
console.log(this)                   // window
let fn = () => console.log(this)
fn()                                // window
fn.call( {name:'hai'} )             // window
```